"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.premintPattern = exports.defaults = void 0;
exports.printStablecoin = printStablecoin;
exports.isAccessControlRequired = isAccessControlRequired;
exports.buildStablecoin = buildStablecoin;
const contract_1 = require("./contract");
const set_access_control_1 = require("./set-access-control");
const add_pausable_1 = require("./add-pausable");
const define_functions_1 = require("./utils/define-functions");
const common_options_1 = require("./common-options");
const set_info_1 = require("./set-info");
const print_1 = require("./print");
const set_clock_mode_1 = require("./set-clock-mode");
exports.defaults = {
    name: 'MyStablecoin',
    symbol: 'MST',
    burnable: false,
    pausable: false,
    premint: '0',
    mintable: false,
    permit: true,
    limitations: false,
    votes: false,
    flashmint: false,
    custodian: false,
    access: common_options_1.defaults.access,
    upgradeable: common_options_1.defaults.upgradeable,
    info: common_options_1.defaults.info,
};
function withDefaults(opts) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return {
        ...opts,
        ...(0, common_options_1.withCommonDefaults)(opts),
        burnable: (_a = opts.burnable) !== null && _a !== void 0 ? _a : exports.defaults.burnable,
        pausable: (_b = opts.pausable) !== null && _b !== void 0 ? _b : exports.defaults.pausable,
        premint: opts.premint || exports.defaults.premint,
        mintable: (_c = opts.mintable) !== null && _c !== void 0 ? _c : exports.defaults.mintable,
        permit: (_d = opts.permit) !== null && _d !== void 0 ? _d : exports.defaults.permit,
        limitations: (_e = opts.limitations) !== null && _e !== void 0 ? _e : exports.defaults.limitations,
        votes: (_f = opts.votes) !== null && _f !== void 0 ? _f : exports.defaults.votes,
        flashmint: (_g = opts.flashmint) !== null && _g !== void 0 ? _g : exports.defaults.flashmint,
        custodian: (_h = opts.custodian) !== null && _h !== void 0 ? _h : exports.defaults.custodian,
    };
}
function printStablecoin(opts = exports.defaults) {
    return (0, print_1.printContract)(buildStablecoin(opts));
}
function isAccessControlRequired(opts) {
    return opts.mintable || opts.limitations !== false || opts.custodian || opts.pausable || opts.upgradeable === 'uups';
}
function buildStablecoin(opts) {
    const allOpts = withDefaults(opts);
    const c = new contract_1.ContractBuilder(allOpts.name);
    const { access, upgradeable, info } = allOpts;
    addBase(c, allOpts.name, allOpts.symbol);
    if (allOpts.burnable) {
        addBurnable(c);
    }
    if (allOpts.pausable) {
        addPausableExtension(c, access);
    }
    if (allOpts.premint) {
        addPremint(c, allOpts.premint);
    }
    if (allOpts.mintable) {
        addMintable(c, access);
    }
    if (allOpts.limitations) {
        addLimitations(c, access, allOpts.limitations);
    }
    if (allOpts.custodian) {
        addCustodian(c, access);
    }
    // Note: Votes requires Permit
    if (allOpts.permit || allOpts.votes) {
        addPermit(c, allOpts.name);
    }
    if (allOpts.votes) {
        const clockMode = allOpts.votes === true ? set_clock_mode_1.clockModeDefault : allOpts.votes;
        addVotes(c, clockMode);
    }
    if (allOpts.flashmint) {
        addFlashMint(c);
    }
    (0, set_access_control_1.setAccessControl)(c, access);
    // Upgradeability is not yet available for the community contracts
    // setUpgradeable(c, upgradeable, access);
    (0, set_info_1.setInfo)(c, info);
    return c;
}
function addBase(c, name, symbol) {
    const ERC20 = {
        name: 'ERC20',
        path: '@openzeppelin/contracts/token/ERC20/ERC20.sol',
    };
    c.addParent(ERC20, [name, symbol]);
    c.addOverride(ERC20, functions._update);
    c.addOverride(ERC20, functions._approve);
}
function addPausableExtension(c, access) {
    const ERC20Pausable = {
        name: 'ERC20Pausable',
        path: '@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol',
    };
    c.addParent(ERC20Pausable);
    c.addOverride(ERC20Pausable, functions._update);
    (0, add_pausable_1.addPauseFunctions)(c, access);
}
function addBurnable(c) {
    c.addParent({
        name: 'ERC20Burnable',
        path: '@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol',
    });
}
exports.premintPattern = /^(\d*)(?:\.(\d+))?(?:e(\d+))?$/;
function addPremint(c, amount) {
    var _a, _b, _c, _d, _e;
    const m = amount.match(exports.premintPattern);
    if (m) {
        const integer = (_b = (_a = m[1]) === null || _a === void 0 ? void 0 : _a.replace(/^0+/, '')) !== null && _b !== void 0 ? _b : '';
        const decimals = (_d = (_c = m[2]) === null || _c === void 0 ? void 0 : _c.replace(/0+$/, '')) !== null && _d !== void 0 ? _d : '';
        const exponent = Number((_e = m[3]) !== null && _e !== void 0 ? _e : 0);
        if (Number(integer + decimals) > 0) {
            const decimalPlace = decimals.length - exponent;
            const zeroes = new Array(Math.max(0, -decimalPlace)).fill('0').join('');
            const units = integer + decimals + zeroes;
            const exp = decimalPlace <= 0 ? 'decimals()' : `(decimals() - ${decimalPlace})`;
            c.addConstructorCode(`_mint(msg.sender, ${units} * 10 ** ${exp});`);
        }
    }
}
function addMintable(c, access) {
    (0, set_access_control_1.requireAccessControl)(c, functions.mint, access, 'MINTER', 'minter');
    c.addFunctionCode('_mint(to, amount);', functions.mint);
}
function addLimitations(c, access, mode) {
    const type = mode === 'allowlist';
    const ERC20Limitation = {
        name: type ? 'ERC20Allowlist' : 'ERC20Blocklist',
        path: `@openzeppelin/community-contracts/contracts/token/ERC20/extensions/${type ? 'ERC20Allowlist' : 'ERC20Blocklist'}.sol`,
    };
    c.addParent(ERC20Limitation);
    c.addOverride(ERC20Limitation, functions._update);
    c.addOverride(ERC20Limitation, functions._approve);
    const [addFn, removeFn] = type
        ? [functions.allowUser, functions.disallowUser]
        : [functions.blockUser, functions.unblockUser];
    (0, set_access_control_1.requireAccessControl)(c, addFn, access, 'LIMITER', 'limiter');
    c.addFunctionCode(`_${type ? 'allowUser' : 'blockUser'}(user);`, addFn);
    (0, set_access_control_1.requireAccessControl)(c, removeFn, access, 'LIMITER', 'limiter');
    c.addFunctionCode(`_${type ? 'disallowUser' : 'unblockUser'}(user);`, removeFn);
}
function addCustodian(c, access) {
    const ERC20Custodian = {
        name: 'ERC20Custodian',
        path: '@openzeppelin/community-contracts/contracts/token/ERC20/extensions/ERC20Custodian.sol',
    };
    c.addParent(ERC20Custodian);
    c.addOverride(ERC20Custodian, functions._update);
    c.addOverride(ERC20Custodian, functions._isCustodian);
    if (access === false) {
        access = 'ownable';
    }
    (0, set_access_control_1.setAccessControl)(c, access);
    switch (access) {
        case 'ownable': {
            c.setFunctionBody([`return user == owner();`], functions._isCustodian);
            break;
        }
        case 'roles': {
            const roleOwner = 'custodian';
            const roleId = 'CUSTODIAN_ROLE';
            const addedConstant = c.addVariable(`bytes32 public constant ${roleId} = keccak256("${roleId}");`);
            if (roleOwner && addedConstant) {
                c.addConstructorArgument({ type: 'address', name: roleOwner });
                c.addConstructorCode(`_grantRole(${roleId}, ${roleOwner});`);
            }
            c.setFunctionBody([`return hasRole(CUSTODIAN_ROLE, user);`], functions._isCustodian);
            break;
        }
        case 'managed': {
            c.addImportOnly({
                name: 'AuthorityUtils',
                path: `@openzeppelin/contracts/access/manager/AuthorityUtils.sol`,
            });
            const logic = [
                `(bool immediate,) = AuthorityUtils.canCallWithDelay(authority(), user, address(this), bytes4(_msgData()[0:4]));`,
                `return immediate;`
            ];
            c.setFunctionBody(logic, functions._isCustodian);
            break;
        }
    }
}
function addPermit(c, name) {
    const ERC20Permit = {
        name: 'ERC20Permit',
        path: '@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol',
    };
    c.addParent(ERC20Permit, [name]);
    c.addOverride(ERC20Permit, functions.nonces);
}
function addVotes(c, clockMode) {
    if (!c.parents.some(p => p.contract.name === 'ERC20Permit')) {
        throw new Error('Missing ERC20Permit requirement for ERC20Votes');
    }
    const ERC20Votes = {
        name: 'ERC20Votes',
        path: '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol',
    };
    c.addParent(ERC20Votes);
    c.addOverride(ERC20Votes, functions._update);
    c.addImportOnly({
        name: 'Nonces',
        path: '@openzeppelin/contracts/utils/Nonces.sol',
    });
    c.addOverride({
        name: 'Nonces',
    }, functions.nonces);
    (0, set_clock_mode_1.setClockMode)(c, ERC20Votes, clockMode);
}
function addFlashMint(c) {
    c.addParent({
        name: 'ERC20FlashMint',
        path: '@openzeppelin/contracts/token/ERC20/extensions/ERC20FlashMint.sol',
    });
}
const functions = (0, define_functions_1.defineFunctions)({
    _update: {
        kind: 'internal',
        args: [
            { name: 'from', type: 'address' },
            { name: 'to', type: 'address' },
            { name: 'value', type: 'uint256' },
        ],
    },
    _approve: {
        kind: 'internal',
        args: [
            { name: 'owner', type: 'address' },
            { name: 'spender', type: 'address' },
            { name: 'value', type: 'uint256' },
            { name: 'emitEvent', type: 'bool' },
        ],
    },
    _isCustodian: {
        kind: 'internal',
        args: [
            { name: 'user', type: 'address' },
        ],
        returns: ['bool'],
        mutability: 'view'
    },
    mint: {
        kind: 'public',
        args: [
            { name: 'to', type: 'address' },
            { name: 'amount', type: 'uint256' },
        ],
    },
    allowUser: {
        kind: 'public',
        args: [
            { name: 'user', type: 'address' }
        ],
    },
    disallowUser: {
        kind: 'public',
        args: [
            { name: 'user', type: 'address' }
        ],
    },
    blockUser: {
        kind: 'public',
        args: [
            { name: 'user', type: 'address' }
        ],
    },
    unblockUser: {
        kind: 'public',
        args: [
            { name: 'user', type: 'address' }
        ],
    },
    pause: {
        kind: 'public',
        args: [],
    },
    unpause: {
        kind: 'public',
        args: [],
    },
    snapshot: {
        kind: 'public',
        args: [],
    },
    nonces: {
        kind: 'public',
        args: [
            { name: 'owner', type: 'address' },
        ],
        returns: ['uint256'],
        mutability: 'view',
    }
});
//# sourceMappingURL=stablecoin.js.map