"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.premintPattern = exports.defaults = void 0;
exports.printERC20 = printERC20;
exports.isAccessControlRequired = isAccessControlRequired;
exports.buildERC20 = buildERC20;
const contract_1 = require("./contract");
const set_access_control_1 = require("./set-access-control");
const add_pausable_1 = require("./add-pausable");
const define_functions_1 = require("./utils/define-functions");
const common_options_1 = require("./common-options");
const set_upgradeable_1 = require("./set-upgradeable");
const set_info_1 = require("./set-info");
const print_1 = require("./print");
const set_clock_mode_1 = require("./set-clock-mode");
exports.defaults = {
    name: 'MyToken',
    symbol: 'MTK',
    burnable: false,
    pausable: false,
    premint: '0',
    mintable: false,
    permit: true,
    votes: false,
    flashmint: false,
    access: common_options_1.defaults.access,
    upgradeable: common_options_1.defaults.upgradeable,
    info: common_options_1.defaults.info,
};
function withDefaults(opts) {
    var _a, _b, _c, _d, _e, _f;
    return {
        ...opts,
        ...(0, common_options_1.withCommonDefaults)(opts),
        burnable: (_a = opts.burnable) !== null && _a !== void 0 ? _a : exports.defaults.burnable,
        pausable: (_b = opts.pausable) !== null && _b !== void 0 ? _b : exports.defaults.pausable,
        premint: opts.premint || exports.defaults.premint,
        mintable: (_c = opts.mintable) !== null && _c !== void 0 ? _c : exports.defaults.mintable,
        permit: (_d = opts.permit) !== null && _d !== void 0 ? _d : exports.defaults.permit,
        votes: (_e = opts.votes) !== null && _e !== void 0 ? _e : exports.defaults.votes,
        flashmint: (_f = opts.flashmint) !== null && _f !== void 0 ? _f : exports.defaults.flashmint,
    };
}
function printERC20(opts = exports.defaults) {
    return (0, print_1.printContract)(buildERC20(opts));
}
function isAccessControlRequired(opts) {
    return opts.mintable || opts.pausable || opts.upgradeable === 'uups';
}
function buildERC20(opts) {
    const allOpts = withDefaults(opts);
    const c = new contract_1.ContractBuilder(allOpts.name);
    const { access, upgradeable, info } = allOpts;
    addBase(c, allOpts.name, allOpts.symbol);
    if (allOpts.burnable) {
        addBurnable(c);
    }
    if (allOpts.pausable) {
        addPausableExtension(c, access);
    }
    if (allOpts.premint) {
        addPremint(c, allOpts.premint);
    }
    if (allOpts.mintable) {
        addMintable(c, access);
    }
    // Note: Votes requires Permit
    if (allOpts.permit || allOpts.votes) {
        addPermit(c, allOpts.name);
    }
    if (allOpts.votes) {
        const clockMode = allOpts.votes === true ? set_clock_mode_1.clockModeDefault : allOpts.votes;
        addVotes(c, clockMode);
    }
    if (allOpts.flashmint) {
        addFlashMint(c);
    }
    (0, set_access_control_1.setAccessControl)(c, access);
    (0, set_upgradeable_1.setUpgradeable)(c, upgradeable, access);
    (0, set_info_1.setInfo)(c, info);
    return c;
}
function addBase(c, name, symbol) {
    const ERC20 = {
        name: 'ERC20',
        path: '@openzeppelin/contracts/token/ERC20/ERC20.sol',
    };
    c.addParent(ERC20, [name, symbol]);
    c.addOverride(ERC20, functions._update);
}
function addPausableExtension(c, access) {
    const ERC20Pausable = {
        name: 'ERC20Pausable',
        path: '@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol',
    };
    c.addParent(ERC20Pausable);
    c.addOverride(ERC20Pausable, functions._update);
    (0, add_pausable_1.addPauseFunctions)(c, access);
}
function addBurnable(c) {
    c.addParent({
        name: 'ERC20Burnable',
        path: '@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol',
    });
}
exports.premintPattern = /^(\d*)(?:\.(\d+))?(?:e(\d+))?$/;
function addPremint(c, amount) {
    var _a, _b, _c, _d, _e;
    const m = amount.match(exports.premintPattern);
    if (m) {
        const integer = (_b = (_a = m[1]) === null || _a === void 0 ? void 0 : _a.replace(/^0+/, '')) !== null && _b !== void 0 ? _b : '';
        const decimals = (_d = (_c = m[2]) === null || _c === void 0 ? void 0 : _c.replace(/0+$/, '')) !== null && _d !== void 0 ? _d : '';
        const exponent = Number((_e = m[3]) !== null && _e !== void 0 ? _e : 0);
        if (Number(integer + decimals) > 0) {
            const decimalPlace = decimals.length - exponent;
            const zeroes = new Array(Math.max(0, -decimalPlace)).fill('0').join('');
            const units = integer + decimals + zeroes;
            const exp = decimalPlace <= 0 ? 'decimals()' : `(decimals() - ${decimalPlace})`;
            c.addConstructorCode(`_mint(msg.sender, ${units} * 10 ** ${exp});`);
        }
    }
}
function addMintable(c, access) {
    (0, set_access_control_1.requireAccessControl)(c, functions.mint, access, 'MINTER', 'minter');
    c.addFunctionCode('_mint(to, amount);', functions.mint);
}
function addPermit(c, name) {
    const ERC20Permit = {
        name: 'ERC20Permit',
        path: '@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol',
    };
    c.addParent(ERC20Permit, [name]);
    c.addOverride(ERC20Permit, functions.nonces);
}
function addVotes(c, clockMode) {
    if (!c.parents.some(p => p.contract.name === 'ERC20Permit')) {
        throw new Error('Missing ERC20Permit requirement for ERC20Votes');
    }
    const ERC20Votes = {
        name: 'ERC20Votes',
        path: '@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol',
    };
    c.addParent(ERC20Votes);
    c.addOverride(ERC20Votes, functions._update);
    c.addImportOnly({
        name: 'Nonces',
        path: '@openzeppelin/contracts/utils/Nonces.sol',
    });
    c.addOverride({
        name: 'Nonces',
    }, functions.nonces);
    (0, set_clock_mode_1.setClockMode)(c, ERC20Votes, clockMode);
}
function addFlashMint(c) {
    c.addParent({
        name: 'ERC20FlashMint',
        path: '@openzeppelin/contracts/token/ERC20/extensions/ERC20FlashMint.sol',
    });
}
const functions = (0, define_functions_1.defineFunctions)({
    _update: {
        kind: 'internal',
        args: [
            { name: 'from', type: 'address' },
            { name: 'to', type: 'address' },
            { name: 'value', type: 'uint256' },
        ],
    },
    mint: {
        kind: 'public',
        args: [
            { name: 'to', type: 'address' },
            { name: 'amount', type: 'uint256' },
        ],
    },
    pause: {
        kind: 'public',
        args: [],
    },
    unpause: {
        kind: 'public',
        args: [],
    },
    snapshot: {
        kind: 'public',
        args: [],
    },
    nonces: {
        kind: 'public',
        args: [
            { name: 'owner', type: 'address' },
        ],
        returns: ['uint256'],
        mutability: 'view',
    }
});
//# sourceMappingURL=erc20.js.map