export interface Contract {
    name: string;
    license: string;
    parents: Parent[];
    natspecTags: NatspecTag[];
    imports: ImportContract[];
    functions: ContractFunction[];
    constructorCode: string[];
    constructorArgs: FunctionArgument[];
    variables: string[];
    upgradeable: boolean;
}
export type Value = string | number | {
    lit: string;
} | {
    note: string;
    value: Value;
};
export interface Parent {
    contract: ImportContract;
    params: Value[];
    importOnly?: boolean;
}
export interface ImportContract extends ReferencedContract {
    path: string;
}
export interface ReferencedContract {
    name: string;
    transpiled?: boolean;
}
export interface Using {
    library: ImportContract;
    usingFor: string;
}
export interface BaseFunction {
    name: string;
    args: FunctionArgument[];
    returns?: string[];
    kind: FunctionKind;
    mutability?: FunctionMutability;
}
export interface ContractFunction extends BaseFunction {
    override: Set<ReferencedContract>;
    modifiers: string[];
    code: string[];
    mutability: FunctionMutability;
    final: boolean;
    comments: string[];
}
export type FunctionKind = 'internal' | 'public';
export type FunctionMutability = typeof mutabilityRank[number];
declare const mutabilityRank: readonly ["pure", "view", "nonpayable", "payable"];
export interface FunctionArgument {
    type: string | ReferencedContract;
    name: string;
}
export interface NatspecTag {
    key: string;
    value: string;
}
export declare class ContractBuilder implements Contract {
    readonly name: string;
    license: string;
    upgradeable: boolean;
    readonly using: Using[];
    readonly natspecTags: NatspecTag[];
    readonly constructorArgs: FunctionArgument[];
    readonly constructorCode: string[];
    readonly variableSet: Set<string>;
    private parentMap;
    private functionMap;
    constructor(name: string);
    get parents(): Parent[];
    get imports(): ImportContract[];
    get functions(): ContractFunction[];
    get variables(): string[];
    addParent(contract: ImportContract, params?: Value[]): boolean;
    addImportOnly(contract: ImportContract): boolean;
    addOverride(parent: ReferencedContract, baseFn: BaseFunction, mutability?: FunctionMutability): void;
    addModifier(modifier: string, baseFn: BaseFunction): void;
    addNatspecTag(key: string, value: string): void;
    private addFunction;
    addConstructorArgument(arg: FunctionArgument): void;
    addConstructorCode(code: string): void;
    addFunctionCode(code: string, baseFn: BaseFunction, mutability?: FunctionMutability): void;
    setFunctionBody(code: string[], baseFn: BaseFunction, mutability?: FunctionMutability): void;
    setFunctionComments(comments: string[], baseFn: BaseFunction): void;
    /**
     * Note: The type in the variable is not currently transpiled, even if it refers to a contract
     */
    addVariable(code: string): boolean;
}
export {};
//# sourceMappingURL=contract.d.ts.map