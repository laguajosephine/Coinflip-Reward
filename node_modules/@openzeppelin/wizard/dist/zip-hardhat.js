"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipHardhat = zipHardhat;
const jszip_1 = __importDefault(require("jszip"));
const print_1 = require("./print");
const solidity_version_json_1 = __importDefault(require("./solidity-version.json"));
const format_lines_1 = require("./utils/format-lines");
const hardhatConfig = (upgradeable) => `\
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
${upgradeable ? `import "@openzeppelin/hardhat-upgrades";` : ''}

const config: HardhatUserConfig = {
  solidity: {
    version: "${solidity_version_json_1.default}",
    settings: {
      optimizer: {
        enabled: true,
      },
    },
  },
};

export default config;
`;
const tsConfig = `\
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  }
}
`;
const gitIgnore = `\
node_modules
.env
coverage
coverage.json
typechain
typechain-types

# Hardhat files
cache
artifacts
`;
const test = (c, opts) => {
    return (0, format_lines_1.formatLinesWithSpaces)(2, ...(0, format_lines_1.spaceBetween)(getImports(c), getTestCase(c)));
    function getTestCase(c) {
        const args = getAddressArgs(c);
        return [
            `describe("${c.name}", function () {`,
            [
                'it("Test contract", async function () {',
                (0, format_lines_1.spaceBetween)([
                    `const ContractFactory = await ethers.getContractFactory("${c.name}");`,
                ], getAddressVariables(args), [
                    `const instance = await ${getDeploymentCall(c, args)};`,
                    'await instance.waitForDeployment();'
                ], getExpects()),
                '});'
            ],
            '});',
        ];
    }
    function getImports(c) {
        return [
            'import { expect } from "chai";',
            `import { ${getHardhatPlugins(c).join(', ')} } from "hardhat";`,
        ];
    }
    function getExpects() {
        if (opts !== undefined) {
            switch (opts.kind) {
                case 'ERC20':
                case 'ERC721':
                    return [`expect(await instance.name()).to.equal("${opts.name}");`];
                case 'ERC1155':
                    return [`expect(await instance.uri(0)).to.equal("${opts.uri}");`];
                case 'Governor':
                case 'Custom':
                    break;
                default:
                    throw new Error('Unknown ERC');
            }
        }
        return [];
    }
    function getAddressVariables(args) {
        const vars = [];
        for (let i = 0; i < args.length; i++) {
            vars.push(`const ${args[i]} = (await ethers.getSigners())[${i}].address;`);
        }
        return vars;
    }
};
function getAddressArgs(c) {
    const args = [];
    for (const constructorArg of c.constructorArgs) {
        if (constructorArg.type === 'address') {
            args.push(constructorArg.name);
        }
    }
    return args;
}
function getDeploymentCall(c, args) {
    return c.upgradeable ? `upgrades.deployProxy(ContractFactory, [${args.join(', ')}])` : `ContractFactory.deploy(${args.join(', ')})`;
}
const script = (c) => {
    const args = getAddressArgs(c);
    return `\
import { ${getHardhatPlugins(c).join(', ')} } from "hardhat";

async function main() {
  const ContractFactory = await ethers.getContractFactory("${c.name}");

  ${args.length > 0 ? '// TODO: Set addresses for the contract arguments below' : ''}
  const instance = await ${getDeploymentCall(c, args)};
  await instance.waitForDeployment();

  console.log(\`${c.upgradeable ? 'Proxy' : 'Contract'} deployed to \${await instance.getAddress()}\`);
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
`;
};
const readme = `\
# Sample Hardhat Project

This project demonstrates a basic Hardhat use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that deploys that contract.

## Installing dependencies

\`\`\`
npm install
\`\`\`

## Testing the contract

\`\`\`
npm test
\`\`\`

## Deploying the contract

You can target any network from your Hardhat config using:

\`\`\`
npx hardhat run --network <network-name> scripts/deploy.ts
\`\`\`
`;
function getHardhatPlugins(c) {
    let plugins = ['ethers'];
    if (c.upgradeable) {
        plugins.push('upgrades');
    }
    return plugins;
}
async function zipHardhat(c, opts) {
    const zip = new jszip_1.default();
    const { default: packageJson } = c.upgradeable ? await Promise.resolve().then(() => __importStar(require("./environments/hardhat/upgradeable/package.json"))) : await Promise.resolve().then(() => __importStar(require("./environments/hardhat/package.json")));
    packageJson.license = c.license;
    const { default: packageLock } = c.upgradeable ? await Promise.resolve().then(() => __importStar(require("./environments/hardhat/upgradeable/package-lock.json"))) : await Promise.resolve().then(() => __importStar(require("./environments/hardhat/package-lock.json")));
    packageLock.packages[''].license = c.license;
    zip.file(`contracts/${c.name}.sol`, (0, print_1.printContract)(c));
    zip.file('test/test.ts', test(c, opts));
    zip.file('scripts/deploy.ts', script(c));
    zip.file('.gitignore', gitIgnore);
    zip.file('hardhat.config.ts', hardhatConfig(c.upgradeable));
    zip.file('package.json', JSON.stringify(packageJson, null, 2));
    zip.file(`package-lock.json`, JSON.stringify(packageLock, null, 2));
    zip.file('README.md', readme);
    zip.file('tsconfig.json', tsConfig);
    return zip;
}
//# sourceMappingURL=zip-hardhat.js.map